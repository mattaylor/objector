const P=Object.prototype;P.map=function(t){return Object.fromEntries(Object.entries(this).map((([n,e])=>[n,t(e,n)])))},P.apply=function(t){return Object.entries(this).map((([n,e])=>this[n]=t(e,n))),this},P.values=function(t){return Object.values(this)},P.keys=function(){return Object.keys(this)},P.entries=function(){return Object.entries(this)},P.filter=function(t){return Object.fromEntries(Object.entries(this).flatMap((([n,e])=>t(e,n)?[[n,e]]:[])))},P.flatMap=function(t){return Object.fromEntries(Object.entries(this).flatMap((([n,e])=>t(n,e))))},P.find=function(t){for(const[n,e]of Object.entries(this))if(t(e,n))return n},P.assign=function(...t){return Object.assign({},this,...t)},P.merge=function(...t){return Object.assign({},...t,this)},P.patch=function(...t){return Object.assign(this,...t)},P.delete=function(...t){for(const n of t)delete this[n];return this},P.some=function(t){return Object.values(this).some(t)},P.every=function(t){return Object.values(this).every(t)},P.toString=function(t){return JSON.stringify(this)},P.json=function(t){return JSON.stringify(this)},P.clone=function(){return Object.assign({},this)},P.join=function(...t){const n=Object.assign({},this);for(const e of t)Object.entries(e).forEach((([t,e])=>n[t]&&=[].concat(n[t],e)));return n},P.split=function(){const t=[];for(const[n,e]of Object.entries(this))e.forEach(((e,r)=>t[r]?t[r][n]=e:t[r]={[n]:e}));return t},P.common=function(t){return Object.fromEntries(Object.entries(this).flatMap((([n,e])=>t[n]==e?[[n,e]]:[])))},P.contains=function(t){for(const[n,e]of Object.entries(t))if(this[n]!=e)return!1;return!0},P.within=function(t){for(const[n,e]of Object.entries(this))if(t[n]!=e)return!1;return!0},P.equals=function(t){const n=Object.entries(this);if(n.length!=Object.keys(t).length)return!1;for(const[e,r]of n)if(t[e]!=r)return!1;return!0},P.size=function(){return Object.keys(this).length};